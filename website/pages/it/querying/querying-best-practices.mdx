---
title: Migliori pratiche di effettuare query
---

Il Graph fornisce un modo decentralizzato per effettuare query dei dati delle blockchain.

I dati del Graph network sono esposti attraverso un GraphQL API, che facilita query dei dati con il linguaggio GraphQL.

Questa pagina vi guiderà attraverso le regole essenziali del linguaggio GraphQL e le migliori pratiche delle GraphQL query.

---

## Effettuare query con GraphQL API

### L'anatomia di una GraphQL query

A differenza del REST API, un GraphQL API si basa su uno schema che definisce le query che possono essere eseguite.

Ad esempio, una query per ottenere un token utilizzando la query `token` avrà il seguente aspetto:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

che restituirà la seguente risposta JSON prevedibile (_quando si passa il valore corretto della variabile `$id`_):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

Le GraphQL query utilizzano il linguaggio GraphQL, definito da [una specificazione](https://spec.graphql.org/).

La query `GetToken` di cui sopra è composta da più parti linguistiche (sostituite di seguito con i segnaposto `[...]`):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

Sebbene l'elenco delle cose da fare e da non fare a livello sintattico sia lungo, ecco le regole essenziali da tenere a mente quando si tratta di scrivere GraphQL query:

- Ogni `queryName` deve essere usato una sola volta per ogni operazione.
- Ogni `field` deve essere utilizzato una sola volta in una selezione (non si può effettuare query di `id` due volte sotto `token`)
- Alcuni `field` o query (come i `token`) restituiscono tipi complessi che richiedono una selezione di sub-field. Se non si fornisce una selezione quando ci si aspetta (o se la si fornisce quando non ci si aspetta, ad esempio su `id`), si genererà un errore. Per conoscere un tipo di campo, consultare [Il Graph Explorer](/network/explorer).
- Qualsiasi variabile assegnata a un argomento deve corrispondere al suo tipo.
- In un determinato elenco di variabili, ciascuna di esse deve essere unica.
- Tutte le variabili definite devono essere utilizzate.

Se non si rispettano le regole di cui sopra, si ottiene un errore dal Graph API.

Per un elenco completo delle regole con esempi di codice, consultare la guida GraphQL Validations guide.

### Invio di una query a un GraphQL API

GraphQL è un linguaggio e un serie di convenzioni che si trasportano su HTTP.

Significa che è possibile effettuare query di un GraphQL API utilizzando lo standard `fetch` (in modo nativo o tramite `@whatwg-node/fetch` or `isomorphic-fetch`).

However, as stated in ["Querying from an Application"](/querying/querying-from-an-application), we recommend you to use our `graph-client` that supports unique features such as:

- Gestione dei subgraph a cross-chain: effettuare query di più subgraph in un'unica query
- [Tracciamento automatico dei blocchi](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [Paginazione automatica](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- Risultato completamente tipizzato

Ecco come effettuare query di The Graph con `graph-client`:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

More GraphQL client alternatives are covered in ["Querying from an Application"](/querying/querying-from-an-application).

Ora che abbiamo trattato le regole di base della sintassi delle GraphQL query, esaminiamo le migliori pratiche di scrittura delle GraphQL query.

---

## Scrivere GraphQL query

### Scrivere sempre query statiche

Una pratica comune (sbagliata) è quella di costruire dinamicamente le stringhe di query come segue:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

Sebbene lo snippet di cui sopra produca una GraphQL query valida, **ha molti svantaggi**:

- rende **più difficile la comprensione** della query nel suo insieme
- gli sviluppatori sono **responsabili della sanificazione sicura dell'interpolazione delle stringhe**
- non inviare i valori delle variabili come parte dei parametri della richiesta **prevenire eventuali cache sul lato server**
- **impedisce agli strumenti di analizzare staticamente la query** (ad esempio, Linter o strumenti di generazione dei tipi)

Per questo motivo, si consiglia di scrivere sempre le query come stringhe statiche:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

Doing so brings **many advantages**:

- Query **facili da leggere e da mantenere**
- Il server GraphQL **gestisce la sanificazione delle variabili**
- **Le variabili possono essere messe in cache** a livello di server
- **Le query possono essere analizzate staticamente dagli strumenti** (maggiori informazioni nelle sezioni successive)

**Nota: come includere i campi in modo condizionato nelle query statiche**

Si potrebbe voler includere il campo `owner` solo in una condizione particolare.

Per questo possiamo sfruttare la direttiva `@include(if:...)` come segue:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

Nota: La direttiva opposta è `@skip(if: ...)`.

### Suggerimenti sulle prestazioni

**"Chiedi quello che vuoi"**

GraphQL è diventato famoso per il suo slogan "Chiedi quello che vuoi".

Per questo motivo, non c'è modo, in GraphQL, di ottenere tutti i campi disponibili senza doverli elencare singolarmente.

Quando si interrogano le GraphQL API, si deve sempre pensare di effettuare query di solo i campi che verranno effettivamente utilizzati.

Una causa comune di over-fetching sono le collezioni di entità. Per impostazione predefinita, le query recuperano 100 entità in un collezione, che di solito sono molte di più di quelle effettivamente utilizzate, ad esempio per la visualizzazione all'utente. Le query dovrebbero quindi essere impostate quasi sempre in modo esplicito e assicurarsi di recuperare solo il numero di entità di cui hanno effettivamente bisogno. Questo vale non solo per le collezioni di primo livello in una query, ma ancora di più per le collezioni di entità annidate.

For example, in the following query:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

The response could contain 100 transactions for each of the 100 tokens.

If the application only needs 10 transactions, the query should explicitly set `first: 10` on the transactions field.

**Combining multiple queries**

Your application might require querying multiple types of data as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

While this implementation is totally valid, it will require two round trips with the GraphQL API.

Fortunately, it is also valid to send multiple queries in the same GraphQL request as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

This approach will **improve the overall performance** by reducing the time spent on the network (saves you a round trip to the API) and will provide a **more concise implementation**.

### Leverage GraphQL Fragments

A helpful feature to write GraphQL queries is GraphQL Fragment.

Looking at the following query, you will notice that some fields are repeated across multiple Selection-Sets (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

Such repeated fields (`id`, `active`, `status`) bring many issues:

- harder to read for more extensive queries
- when using tools that generate TypeScript types based on queries (_more on that in the last section_), `newDelegate` and `oldDelegate` will result in two distinct inline interfaces.

A refactored version of the query would be the following:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using GraphQL `fragment` will improve readability (especially at scale) but also will result in better TypeScript types generation.

When using the types generation tool, the above query will generate a proper `DelegateItemFragment` type (_see last "Tools" section_).

### GraphQL Fragment do's and don'ts

**Fragment base must be a type**

A Fragment cannot be based on a non-applicable type, in short, **on type not having fields**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` is a **scalar** (native "plain" type) that cannot be used as a fragment's base.

**How to spread a Fragment**

Fragments are defined on specific types and should be used accordingly in queries.

Example:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` and `oldDelegate` are of type `Transcoder`.

It is not possible to spread a fragment of type `Vote` here.

**Define Fragment as an atomic business unit of data**

GraphQL Fragment must be defined based on their usage.

For most use-case, defining one fragment per type (in the case of repeated fields usage or type generation) is sufficient.

Here is a rule of thumb for using Fragment:

- when fields of the same type are repeated in a query, group them in a Fragment
- when similar but not the same fields are repeated, create multiple fragments, ex:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The essential tools

### GraphQL web-based explorers

Iterating over queries by running them in your application can be cumbersome. For this reason, don't hesitate to use [The Graph Explorer](https://thegraph.com/explorer) to test your queries before adding them to your application. The Graph Explorer will provide you a preconfigured GraphQL playground to test your queries.

If you are looking for a more flexible way to debug/test your queries, other similar web-based tools are available such as [Altair](https://altair.sirmuel.design/) and [GraphiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

In order to keep up with the mentioned above best practices and syntactic rules, it is highly recommended to use the following workflow and IDE tools.

**GraphQL ESLint**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: should a given variable stay unused?
- and more!

This will allow you to **catch errors without even testing queries** on the playground or running them in production!

### IDE plugins

**VSCode and GraphQL**

The [GraphQL VSCode extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) is an excellent addition to your development workflow to get:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets
- go to definition for fragments and input types

If you are using `graphql-eslint`, the [ESLint VSCode extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) is a must-have to visualize errors and warnings inlined in your code correctly.

**WebStorm/Intellij and GraphQL**

The [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-graphql/) will significantly improve your experience while working with GraphQL by providing:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets

More information on this [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) that showcases all the plugin's main features.
