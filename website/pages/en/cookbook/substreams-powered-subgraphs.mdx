---
title: Substreams-powered subgraphs
---

Substreams is a new framework for processing blockchain data, developed by StreamingFast for The Graph Network. A substreams modules can output entity changes, which are compatible with Subgraph entities. A subgraph can use such a Substreams module as a data source, bringing the indexing speed and additional data of Substreams to subgraph developers.

> This cookbook uses the [Messari Eth Supply substream as a reference](https://github.com/messari/substreams/tree/master/eth-supply). [Learn more about Substreams development](/substreams/README).

## substreams.yaml

A Substreams package can be used by a subgraph as long as it has a module which outputs compatible entity changes. The following simple Substreams package has a `map_entity_changes` module with a `proto:substreams.entity.v1.EntityChanges` output:

```yaml
specVersion: v0.1.0
package:
  name: eth_supply
  version: v0.1.0

imports:
  eth: 'https://github.com/streamingfast/sf-ethereum/releases/download/v0.10.2/ethereum-v0.10.4.spkg'
  entity: 'https://github.com/streamingfast/substreams-entity-change/releases/download/v0.2.1/substreams-entity-change-v0.2.1.spkg'

binaries:
  default:
    type: wasm/rust-v1
    file: '../target/wasm32-unknown-unknown/release/eth_supply.wasm'

modules:
  - name: map_supply_delta
    kind: map
    inputs:
      - source: sf.ethereum.type.v2.Block
    output:
      type: 'proto:messari.eth_supply.v1.EthSupply'

  - name: store_supply
    kind: store
    updatePolicy: add
    valueType: bigint
    inputs:
      - map: map_supply_delta

  - name: map_output
    kind: map
    inputs:
      - store: store_supply
    output:
      type: 'proto:messari.eth_supply.v1.EthSupply'

  - name: map_entity_changes
    kind: map
    inputs:
      - source: sf.substreams.v1.Clock
      - map: map_supply_delta
      - map: map_output
    output:
      type: 'proto:substreams.entity.v1.EntityChanges'

protobuf:
  files:
    - eth_supply.proto
  importPaths:
    - './proto/v1'
```

This `map_entity_changes` module is the final step in this Substreams package, and takes processed inputs and creates the required entity changes:

```rust
use hex::FromHex;

use substreams::pb::substreams::Clock;
use substreams::scalar::BigInt;
use substreams_entity_change::change::ToField;
use substreams_entity_change::pb::entity::entity_change::Operation;
use substreams_entity_change::pb::entity::{EntityChange, EntityChanges};

use substreams_helper::convert::BigIntDeserializeExt;

use crate::pb::eth_supply::v1::EthSupply;

#[substreams::handlers::map]
fn map_entity_changes(
    clock: Clock,
    block_delta: EthSupply,
    cumulative: EthSupply,
) -> Result<EntityChanges, substreams::errors::Error> {
    let block_hash: String = clock.id;
    let hash_bytes: Vec<u8> = FromHex::from_hex::<&String>(&block_hash).unwrap();
    let timestamp = BigInt::from(clock.timestamp.unwrap().seconds);
    let block_num = clock.number;

    let entity_changes = vec![EntityChange {
        entity: "Supply".to_string(),
        id: block_hash.to_string(),
        ordinal: 1,
        operation: Operation::Create.into(),
        fields: vec![
            hash_bytes.to_field("blockHash".to_string()),
            block_num.to_field("blockNumber".to_string()),
            timestamp.to_field("timestamp".to_string()),
            cumulative
                .total
                .unwrap()
                .deserialize()
                .to_field("currentSupply"),
            cumulative
                .genesis
                .unwrap()
                .deserialize()
                .to_field("genesisSupply"),
            cumulative
                .block_rewards
                .unwrap()
                .deserialize()
                .to_field("cumulativeMiningRewards"),
            cumulative
                .uncle_rewards
                .unwrap()
                .deserialize()
                .to_field("cumulativeUncleRewards"),
            cumulative
                .burned
                .unwrap()
                .deserialize()
                .to_field("cumulativeBurnedFees"),
            block_delta
                .block_rewards
                .unwrap()
                .deserialize()
                .to_field("blockMiningReward"),
            block_delta
                .uncle_rewards
                .unwrap()
                .deserialize()
                .to_field("blockUncleReward"),
            block_delta
                .burned
                .unwrap()
                .deserialize()
                .to_field("blockBurnedFees"),
        ],
    }];
    Ok(EntityChanges { entity_changes })
}
```

An `EntityChange` must specify the entity type, ID (which can be a String, or Bytes, in line with subgraph entity IDs), operation, and fields.

> The ID and fields must be compatible with the `schema.graphql` definition on the corresponding subgraph for the entity type.

The operation can be "Create", "Update" or "Delete".

## subgraph.yaml

Substreams-powered subgraphs introduce a new `kind` of data source, "substreams". Such subgraphs can only have one data source. This data source must specify the Substreams network, the Substreams package as a relative file location, and the module within that Substreams package which produces subgraph-compatible entity changes (in this case `map_entity_changes`, from the Substreams package above). The mapping is specified, but simply identifies the mapping kind ("substreams/graph-entities") and the apiVersion.

```yaml
specVersion: 0.0.4
description: Ethereum supply subgraph powered by substreams
repository: https://github.com/messari/substreams/eth-supply
schema:
  file: ./schema.graphql

dataSources:
  - kind: substreams
    name: eth_supply
    network: mainnet
    source:
      package:
        moduleName: map_entity_changes
        file: eth-supply-v0.1.0.spkg
    mapping:
      kind: substreams/graph-entities
      apiVersion: 0.0.5
```

## schema.graphql

The `subgraph.yaml` also references a schema file. The requirements for this file are unchanged, but the entities specified must be compatible with the entity changes produced by the Substreams module referenced in the `subgraph.yaml`.

```graphql
type Supply @entity(immutable: true) {
  id: Bytes!

  blockHash: Bytes!
  blockNumber: BigInt!
  timestamp: BigInt!

  " Total ETH in existence at this block. All initial supply and rewards added up, minus burned fees. "
  currentSupply: BigInt!

  " ETH created at genesis. "
  genesisSupply: BigInt!

  " ETH created as block mining rewards (up until the merge). "
  cumulativeMiningRewards: BigInt!

  " ETH created as part of including uncle blocks (up until the merge). "
  cumulativeUncleRewards: BigInt!

  " ETH burned because of base fee burn after eip1559. "
  cumulativeBurnedFees: BigInt!

  " ETH created in this block as mining rewards. "
  blockMiningReward: BigInt!

  " ETH created in this block as uncle rewards. "
  blockUncleReward: BigInt!

  " Eth burned in this block via eip1559. "
  blockBurnedFees: BigInt!
}
```

Given the above, subgraph developers can use Graph CLI >=0.51.0 to deploy this Substreams-powered subgraph.

```bash
graph deploy
```

> Substreams-powered subgraphs indexing mainnet Ethereum can be deployed to the [Subgraph Studio](https://thegraph.com/studio/).

## Serving Substreams-powered subgraphs

In order to serve Substreams-powered subgraphs, Graph Node must be configured with a Substreams provider for the relevant network, as well as a Firehose or RPC to track the chain head. These providers can be configured via a `config.toml` file:

```toml
[chains.mainnet]
shard = "main"
protocol = "ethereum"
provider = [
  { label = "substreams-provider-mainnet",
    details = { type = "substreams",
    url = "https://mainnet-substreams-url.grpc.substreams.io/",
    token = "exampletokenhere" }},
  { label = "firehose-provider-mainnet",
    details = { type = "firehose",
    url = "https://mainnet-firehose-url.grpc.firehose.io/",
    token = "exampletokenhere" }},
]
```
